# Описание

Лабораторка в котоорой можно протестировать разные варианты решения проблемы доступности внешних сервисов с объектов из России

В данной лаборатории весь публичный трафк идёт через провайтеда.
Это нужно чтобы разделить сеть на разные домены 2 уровня.
И так получается реалистичная схема

Minio блокирует трафик идущий из локации в России

Client без проблем может подключаться к любому публичному адресу, он нужен для проверки доступности ингреса

Ноды могут выходить в реальный интернет через провайдера

Внешние публичные IP:
| Node | IP |
| --- | --- |
| client | `1.1.1.1` |
| router | `2.2.2.1` |
| ingress | `3.3.3.1` |
| minio | `4.4.4.1` |
| chr | `5.5.5.1` |

> Схема выдачи публичных IP следующая: К какому порту ISP подключена нода, такой номер указывается в 1, 2 и 3 октете, шлюз нужно указать как 2 с 30 наской

# 1 Вариант
Забрать внешний IP у ингреса и гнать входящий трафик через микрот

ingress
```
ip a delete 3.3.3.1 dev eth2
```

router
```
/ip address add address=3.3.3.1/30 interface=ether2
/ip route add dst-address=0.0.0.0/0 gateway=3.3.3.2
/ip firewall nat
add chain=dstnat dst-address=3.3.3.1 action=dst-nat to-addresses=[/ip dhcp-server lease get [find where host-name="ingress"] address]
```

Проблема следующая: исходящий трафик будет выходить через адреса роутера начиная от наименьшего (2.2.2.1)
Если прийдется указывать что ingress должен выходить во внешнюю сеть через отдельный IP то потребуется больше ресурсов процессора, а на локациях стоят коммутаторы это может их нагрузить

# 2 вариант
Указание отдельных маршрутов на ingress

## Статическая маршрутизация
ingress
```
ip r add 4.4.4.1 via 192.168.99.1
```

delete
```
ip r delete 4.4.4.1 via 192.168.99.1
```

Минус в том, что таких тачек много и прийдется раскидывать такие маршруты на многих узлах при проблемах

## Динамическая маршрутизация
ingress
```
apk add frr
sed '/^ripd/s/no$/yes/' /etc/frr/daemons -i
/usr/lib/frr/zebra -d
/usr/lib/frr/ripd -d
/usr/lib/frr/mgmtd -d
vtysh
```

vtysh
```
configure terminal
router rip
version 2
network eth1
neighbor 192.168.99.1
exit
interface eth1
ip rip receive version 2
exit
exit
write memory
exit
```

check
```
vtysh -c "show ip rip"
vtysh -c "show ip rip status"
vtysh -c "show ip route rip"
```

Плюс в том, что маршруты получаются автоматически при внесении настроек сетевым инженером
Минус в сложной настройке на стороне сервера и сетевому инженеру необходим доступ на сервер для дебага

# 3 вариант
Указание дефолтного маршрута через микрот более приоритетным

```
ip r add default via 3.3.3.2 dev eth2 metric 1000
ip r delete default via 3.3.3.2 dev eth2
```

Самый простой вариант и по сути в такой ситуации самый лучший
